var searchIndex = {};
searchIndex["rtlsdr"] = {"doc":"","items":[[3,"Device","rtlsdr","",null,null],[3,"HwInfo","","",null,null],[12,"vendor_id","","",0,null],[12,"product_id","","",0,null],[12,"manufact","","",0,null],[12,"product","","",0,null],[12,"serial","","",0,null],[12,"have_serial","","",0,null],[12,"enable_ir","","",0,null],[12,"remote_wakeup","","",0,null],[4,"SamplingMode","","Sampling modes.",null,null],[13,"None","","",1,null],[13,"IADC","","",1,null],[13,"QADC","","",1,null],[13,"Unknown","","",1,null],[4,"Error","","",null,null],[13,"NoError","","",2,null],[13,"Io","","",2,null],[13,"InvalidParam","","",2,null],[13,"Access","","",2,null],[13,"NoDevice","","",2,null],[13,"NotFound","","",2,null],[13,"Busy","","",2,null],[13,"Timeout","","",2,null],[13,"Overflow","","",2,null],[13,"Pipe","","",2,null],[13,"Interrupted","","",2,null],[13,"NoMem","","",2,null],[13,"NotSupported","","",2,null],[13,"NoValidEEPROMHeader","","",2,null],[13,"StringValueTooLong","","",2,null],[13,"StringDescriptorInvalid","","",2,null],[13,"StringDescriptorTooLong","","",2,null],[13,"Other","","",2,null],[5,"get_device_count","","Returns the number of devices detected.",null,{"inputs":[],"output":{"name":"i32"}}],[5,"get_device_name","","Returns the name of the device by index.",null,{"inputs":[{"name":"i32"}],"output":{"name":"string"}}],[5,"get_device_usb_strings","","Returns the information of a device by index.",null,null],[5,"get_index_by_serial","","Returns a device index by serial id.",null,{"inputs":[{"name":"string"}],"output":{"name":"i32"}}],[5,"open","","Returns an opened device by index.",null,null],[6,"ReadAsyncCbT","","read async callback function",null,null],[17,"DEFAULT_FC","","",null,null],[17,"DEFAULT_RS","","",null,null],[17,"DEFAULT_READ_SIZE","","",null,null],[17,"CRYSTAL_FREQ","","",null,null],[17,"DEFAULT_SAMPLE_RATE","","",null,null],[17,"DEFAULT_ASYNC_BUF_NUMBER","","",null,null],[17,"DEFAULT_BUF_LENGTH","","",null,null],[17,"MIN_BUF_LENGTH","","",null,null],[17,"MAX_BUF_LENGTH","","",null,null],[17,"MAX_STR_SIZE","","Hardware info strings (product, manufacturer, serial) maximum size.\nMAX_STR_SIZE = (max string length - 2 (header bytes)) \\ 2. Where each\ninfo character is followed by a null character.",null,null],[11,"clone","","",3,null],[11,"fmt","","",0,null],[11,"clone","","",2,null],[11,"fmt","","",2,null],[11,"close","","Close the device.",3,null],[11,"set_xtal_freq","","Sets the crystal oscillator frequencies.",3,null],[11,"get_xtal_freq","","Returns the crystal oscillator frequencies.\nTypically both ICs (rtlsdr and tuner) use the same clock.",3,null],[11,"get_usb_strings","","Returns the device information (manufact, product, serial).\nNote, strings may be empty.",3,null],[11,"write_eeprom","","Writes information data to the EEPROM.",3,null],[11,"read_eeprom","","Returns information data read from the EEPROM.",3,null],[11,"set_center_freq","","Sets the center frequency.",3,null],[11,"get_center_freq","","Returns the tuned frequency or zero on error.",3,null],[11,"set_freq_correction","","Sets the frequency correction.",3,null],[11,"get_freq_correction","","Returns the frequency correction value.",3,null],[11,"get_tuner_type","","Returns the tuner type.",3,null],[11,"get_tuner_gains","","Returns a list of supported tuner gains.\nValues are in tenths of dB, e.g. 115 means 11.5 dB.",3,null],[11,"set_tuner_gain","","Sets the tuner gain. Note, manual gain mode\nmust be enabled for this to work. Valid gain values may be\nqueried using get_tuner_gains.",3,null],[11,"get_tuner_gain","","Returns the tuner gain.",3,null],[11,"set_tuner_bandwidth","","Sets the device bandwidth.",3,null],[11,"set_tuner_if_gain","","Sets the intermediate frequency gain.",3,null],[11,"set_tuner_gain_mode","","Sets the gain mode, automatic or manual.\nManual gain mode must be enabled for the gain setter function to work.",3,null],[11,"set_sample_rate","","Sets the sample rate.",3,null],[11,"get_sample_rate","","Returns the sample rate.",3,null],[11,"set_testmode","","Sets device to test mode.",3,null],[11,"set_agc_mode","","Sets the AGC mode.",3,null],[11,"set_direct_sampling","","Sets the direct sampling mode.",3,null],[11,"get_direct_sampling","","Returns the state of direct sampling mode.",3,null],[11,"set_offset_tuning","","Sets the offset tuning mode for zero-IF tuners, which\navoids problems caused by the DC offset of the ADCs and 1/f noise.",3,null],[11,"get_offset_tuning","","Returns the offset tuning mode.",3,null],[11,"reset_buffer","","Resets the streaming buffer.",3,null],[11,"read_sync","","Performs a synchronous read of samples and returns\nthe number of samples read.",3,null],[11,"read_async","","Reads samples asynchronously. Note, this function will block until\ncanceled using cancel_async. ReadAsyncCbT is a package global variable.",3,null],[11,"cancel_async","","Cancels all pending asynchronous operations.",3,null],[11,"get_hw_info","","Gets the dongle&#39;s information items.",3,null],[11,"set_hw_info","","SetCenterFreq the dongle&#39;s information items.",3,null]],"paths":[[3,"HwInfo"],[4,"SamplingMode"],[4,"Error"],[3,"Device"]]};
initSearch(searchIndex);
